embed
    {{tex-preamble        
    }}
metavar termvar,    x, y, z, w, f  ::=
indexvar indices,   m, n, k, i, j ::=

grammar

K :: 'kinds_' ::= {{com Kinds}}  
  | Pow ( A )         ::   :: Power
  | ( x : K1 ) -> K2  ::   :: TArrow
  | [ A / x ] K       :: M :: Subst
  | Type              :: S :: Type

A, B, C, D, T :: 'types_' ::= {{com Types}}
  | x                                  ::   :: Var
  | function x : K { T }               ::   :: TFun
  | A B                                ::   :: TApp
  | Top                                ::   :: Top
  | A -> B                             ::   :: Arrow
  | ( x : K ) -> B                     ::   :: Forall
  | Some ( x : K ) . B                 ::   :: Some
  | Record { x1 : T1 , ... , xi : Ti } ::   :: TRecord   
  | [ A / x ] B                        :: M :: Subst
  | ( A )                              :: S :: Paren

t :: 'terms_' ::= {{com Terms }}
  | top                                ::   :: Top
  | x                                  ::   :: Var
  | function x : T { t }               ::   :: Fun
  | function x : K { t }               ::   :: TFun
  | t1 t2                              ::   :: App
  | t T                                ::   :: TApp
  | pack ( T1 , e ) T2                 ::   :: Pack  
  | let ( A , x ) = t1 in t2           ::   :: Unpack
  | record { x1 = t1 , ... , xi = ti } ::   :: Record
  | t . x                              ::   :: FieldSelection
  | ( t )                              :: S :: Paren
  | [ A / x ] t                        :: M :: TSubst
  | [ t1 / x ] t2                      :: M :: Subst

G {{tex \Gamma }} :: 'contexts_' ::= {{com Contexts }}
  | empty       ::   :: Empty
  | G , x : T   ::   :: VarExt
  | G , x : K   ::   :: TVarExt
  | G , x <= T  :: S :: TSVarExt
  | x : T       :: M :: Var
  | x : K       :: M :: TVar
  | x <= T      :: S :: TSVar
  | G1 , G2     :: M :: Concat

terminals :: 'terminal_' ::=
  | class     :: :: class
  {{tex \mathsf{Class} }}
  | ->        :: :: RArrow
  {{tex \to }}
  | <=        :: :: Leq
  {{tex \leq }}
  | empty     :: :: Empty
  {{tex \emptyset }}
  | Type      :: :: Type
  {{tex \mathsf{Type} }}
  | Kind      :: :: Kind
  {{tex \mathsf{Kind} }}
  | Top       :: :: Top
  {{tex \mathsf{Top} }}
  | top       :: :: TopTerm
  {{tex \mathsf{top} }}
  | Forall    :: :: Forall
  {{tex \mathsf{Forall} }}
  | Some      :: :: Some
  {{tex \mathsf{Some} }}
  | Record    :: :: Record
  {{tex \mathsf{Record} }}
  | Function  :: :: Function
  {{tex \mathsf{function} }}
  | pack      :: :: Pack
  {{tex \mathsf{Pack} }}
  | let       :: :: let
  {{tex \mathsf{let} }}
  | in        :: :: in
  {{tex \mathsf{in} }}
  | forall    :: :: MForall
  {{tex \forall }}
  | subseteq  :: :: Subseteq
  {{tex \subseteq }}
  | Pow       :: :: Power
  {{tex \mathsf{Pow} }}
  | dom       :: :: Domain
  {{tex \mathsf{dom} }}
  | nin       :: :: Nin
  {{tex \not\in }}
  | <:>       :: :: TEq
  | <::>      :: :: KEq
  | <->       :: :: Eq
  {{tex \rightleftarrow }}

dotvar :: 'dotvar_' ::=
  | x1 , ... , xi :: :: Dotvar

formula :: 'formula_' ::=
    | judgement1                        ::   :: judgement
    | judgement1 , ... , judgementi     ::   :: judgementM
    | formula1 && formula2              ::   :: Quad
    | forall x = y , formula            :: M :: Forall
    | ( formula )                       :: S :: parens
    {{tex [[formula]] }}
    | { dotvar1 } subseteq { dotvar2 }  :: M :: SSL
    | x nin dom ( G )                   :: M :: Dom    

defns
  Judgments :: '' ::=

defn 
  G |- :: :: validctx :: 'C_'
  {{com Valid Contexts }}
by  

  --------- :: Empty
  empty |- 

  G |- T : K && x nin dom(G)
  -------------------------- :: TVar
  G, x <= T |-

  G |- T : Type && x nin dom(G)
  ----------------------------- :: TVar
  G, x : T |-

  G |- K : Kind && x nin dom(G)
  ----------------------------- :: KVar
  G, x : K |-

defn 
  G |- K : Kind :: :: wf_kinds :: 'WK_'
  {{com Wellformed Kinds }}
by  

  G |- A : Type
  ------------------ :: Power
  G |- Pow(A) : Kind 

  G |- K1 : Kind && G, x : K1 |- K2 : Kind
  ---------------------------------------- :: Arrow
  G |- (x : K1) -> K2 : Kind


defn 
  G |- T : K :: :: kinding :: 'K_'
  {{com Kind Checking }}
by  

  G |- A : K1 && G |- K1 <= K2
  ---------------------------- :: Sub
  G |- A : K2

  G |- A : Type
  --------------- :: Power
  G |- A : Pow(A)

  G1, x : K,G2 |-  
  --------------------- :: TVar
  G, x : K |- x : K  

  G |- K1 : Kind && G, x : K1 |- T2 : K2
  -------------------------------------------- :: FunI
  G |- function x : K1 { T2 } : (x : K1) -> K2
  
  G |- A : (x : K1) -> K2  &&  G |- B : K1
  ---------------------------------------- :: FunE
  G |- A B : [B/x]K2  

  G |- A : K1 && G |- K1 <::> K2
  ------------------------------ :: Ext
  G |- A : K2

  G |- 
  -------------- :: Top
  G |- Top : Type

  G |- A : Type && G |- B : Type
  ------------------------------ :: Arrow
  G |- A -> B : Type

  G |- K : Kind && G, x : K |- B : Type
  ------------------------------------- :: Forall
  G |- (x : K) -> B : Type

  G |- K : Kind && G, x : K |- B : Type
  ------------------------------------- :: Some
  G |- Some (x : K) . B : Type

  G |-  
  G |- T1 : Type , ... , G |- Ti : Type
  ---------------------------------------------- :: Record
  G |- Record { x1 : T1 , ... , xi : Ti } : Type

defn 
  G |- K1 <= K2 :: :: subkinding :: 'SK_'
  {{com SubKinding }}
by

  G |- K1 <::> K2
  --------------- :: Refl
  G |- K1 <= K2

  G |- K1 <= K2 && G |- K2 <= K3
  ------------------------------ :: Trans
  G |- K1 <= K2

  G |- A <= B
  --------------------- :: Power
  G |- Pow(A) <= Pow(B)

  G |- K1 : Kind && G, x : K1 |- K2 <= K3
  --------------------------------------- :: Arrow
  G |- (x : K1) -> K2 <= (x : K1) -> K3

defn
  G |- A <= B :: :: subtyping :: 'ST_'
  {{com Subtyping }}
by  

  G |- B <:> C : Type
  G |- A <= B && G |- C : K
  ------------------------- :: Conv
  G |- A <= C

  G, x <= A |-   
  ------------------- :: TVar
  G, x <= A |- x <= A

  G |- A <:> B : Type
  ------------------- :: Refl
  G |- A <= B

  G |- A <= B && G |- B <= C
  -------------------------- :: Trans
  G |- A <= C

  G |- A : Type
  ------------- :: Top
  G |- A <= Top

  G |- C <= A && G |- B <= D
  -------------------------- :: Arrow
  G |- A -> B <= C -> D
  
  G |- K2 <= K1 && G, x : K2 |- B <= D
  ------------------------------------- :: Forall
  G |- (x : K1) -> B <= (x : K2) -> D

  G |- Some(x : Pow(A)).B : Type
  G |- A <= C && G, x <= C |- B <= D
  ------------------------------------------------- :: Some
  G |- Some (x : Pow(A)) . B <= Some (x : Pow(B)).D  

  {y1 , ... , yn} subseteq {x1 , ... , xm}
  forall xi = yj, G |- Ai <= Bj
  G |- Record {x1 : A1 , ..., xm : Am } : Type
  ----------------------------------------------------------------- :: Record
  G |- Record {x1 : A1,...,xm : Am} <= Record {y1 : B1,...,yn : Bn}

  G, x <= Top |- A <= B
  ------------------------------------------------- :: Fun
  G |- function x : K { A } <= function x : K { B }

  G |- A <= B && G |- A C : K
  --------------------------- :: App
  G |- A C <= B C

defn 
  G |- t : T :: :: typing :: 'T_'
  {{com Type Checking }}
by

  G |- t : A && G |- A <= B
  ------------------------- :: Sub
  G |- t : B

  G |- t : A && G |- A <:> B : Type
  --------------------------------- :: TExt
  G |- t : B

  G |-
  -------------- :: Top
  G |- top : Top

  G, x : A |-
  ----------------- :: Var
  G, x : A |- x : A

  G |- K : Kind && G, x : K |- t : B
  ----------------------------------------- :: TArrow
  G |- function x : K  { t } : (x : K) -> B

  G |- t1 : (x : K) -> B && G |- A : K
  ------------------------------------ :: TApp
  G |- t1 A : [A/x]B

  G, x : A |- t : B
  ---------------------------------- :: Arrow
  G |- function x : A { t } : A -> B

  G |- t1 : A -> B && G |- t2 : A
  ------------------------------- :: App
  G |- t1 t2 : B

defn
  G |- K1 <::> K2 :: :: keq :: 'KEq_'
  {{com kind equality }}
by

  G |- K1 <::> K2
  --------------- :: Sym
  G |- K2 <::> K1

  G |- K1 <::> K2 && G |- K2 <::> K3
  ---------------------------------- :: Trans
  G |- K1 <::> K3

  G |- A <:> B : Type
  ----------------------- :: Power
  G |- Pow(A) <::> Pow(B)

  G |- K1 <::> K3 && G,x : K1 |- K2 <::> K4
  ----------------------------------------- :: Arrow
  G |- (x : K1) -> K2 <::> (x : K3) -> K4

defn
  G |- A <:> B : K :: :: tyeq :: 'TEq_'
  {{com type equality }}
by

  G |- A <:> B : K
  ---------------- :: Sym
  G |- B <:> A : K

  G |- A <:> B : K && G |- B <:> C : K
  ------------------------------------ :: Trans
  G |- A <:> C : K

  G |- x : K
  ---------------- :: Var
  G |- x <:> x : K

  G |-
  ----------------------- :: Top
  G |- Top <:> Top : Type

  G |- K1 <::> K2 && G, x : K1 |- A <:> B : Type
  --------------------------------------------- :: Forall
  G |- (x : K1) -> A <:> (x : K2) -> B : Type

  G |- A1 <:> A2 : Type && G |- B1 <:> B2 : Type
  ----------------------------------------------- :: Arrow
  G |- A1 -> B1 <:> A2 -> B2 : Type

  G |- K1 <::> K2 && G,x : K1 |- A <:> B : K3
  -------------------------------------------------------------------- :: Fun
  G |- function x : K1 { A } <:>function x : K2 { B } : (x : K1) -> K3

  G |- A1 <:> A2 : (x : K1) -> K2 && G |- B1 <:> B2 : K1
  ------------------------------------------------------ :: App
  G |- A1 B1 <:> A2 B2 : [A/x]K2

  G |- B : (x : K1) -> K2 && x nin dom(G)
  --------------------------------------------------- :: Eta
  G |- function x : K1 { B x } <:> B : (x : K1) -> K2

  G |- (function x : K1 { B }) A : K2
  ---------------------------------------------- :: Beta
  G |- (function x : K1 { B }) A <:> [A/x]B : K2

defn
  G |- t1 <-> t2 : A :: :: termeq :: 'Eq_'
  {{com term equality }}
by

G |- t1 <-> t2 : A
------------------ :: Sym
G |- t2 <-> t1 : A

G |- t1 <-> t2 : A && G |- t2 <-> t3 : A
---------------------------------------- :: Trans
G |- t1 <-> t3 : A

G |- t1 <-> t2 : A && G |- A <= B
--------------------------------- :: Sub
G |- t1 <-> t2 : B

G |- x : A
---------------- :: Var
G |- x <-> x : A

G |-
---------------------- :: Top
G |- top <-> top : Top

G |- t1 <-> t1 : Top && G |- t2 <-> t2 : Top
-------------------------------------------- :: Collapse
G |- t1 <-> t2 : Top

G |- K1 <::> K2 && G,x : K1 |- t1 <-> t2 : B
---------------------------------------------------------------------- :: TFun
G |- function x : K1 { t1 } <-> function x : K2 { t2 } : (x : K1) -> B

G |- A1 <:> A2 : Type && G,x : A1 |- t1 <-> t2 : B
---------------------------------------------------------------- :: Fun
G |- function x : A1 { t1 } <-> function x : A2 { t2 } : A1 -> B

G |- t1 <-> t2 : (x : K) -> B && G |- A1 <:> A2 : K
--------------------------------------------------- :: TApp
G |- t1 A1 <-> t2 A2 : [A1/x]B

G |- t1 <-> t3 : A -> B && G |- t2 <-> t4 : A
--------------------------------------------- :: TApp
G |- t1 t2 <-> t3 t4 : B

G |- t : (x : K) -> B && x nin dom(G)
------------------------------------------------ :: TEta
G |- function x : K { t x } <-> t : (x : K) -> B

G |- t : A -> B && x nin dom(G)
------------------------------------------ :: Eta
G |- function x : A { t x } <-> t : A -> B

G |- (function x : K { t }) A : B
-------------------------------------------- :: TBeta
G |- (function x : K { t }) A <-> [A/x]t : B

G |- (function x : K { t1 }) t2 : B
------------------------------------------------ :: Beta
G |- (function x : K { t1 }) t2 <-> [t1/x]t2 : B
